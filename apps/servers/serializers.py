# coding=utf-8# auth: zhangyiling# time: 2019/3/11 下午11:19# description: 服务器序列化器import loggingfrom rest_framework import serializersfrom manufacturers.models import Manufacturers, ProductModelfrom servers.models import Server, NetworkDevice, IPlogger = logging.getLogger(__name__)class ServerAutoReportSerializer(serializers.Serializer):    """服务器自动导入数据序列化,序列化使用到多张表，不适合 ModelSerializer."""    ip = serializers.IPAddressField(required=True, help_text='ip地址')    hostname = serializers.CharField(required=True, max_length=50, help_text='主机名')    cpu = serializers.CharField(required=True, help_text='cpu')    mem = serializers.CharField(required=True, help_text='内存')    disk = serializers.CharField(required=True, help_text='磁盘')    os = serializers.CharField(required=True, help_text='系统')    # 不能使用下面的方式: 传入厂商的名称类型是 str    # manufacturer = serializers.PrimaryKeyRelatedField(many=False, queryset=Manufacturers.objects.all())    manufacturer = serializers.CharField(required=True, help_text='云产商名称')    model_name = serializers.CharField(required=True, help_text='型号名称')    uuid = serializers.CharField(required=True, help_text='uuid')    # Service 表中没有该字段    network = serializers.JSONField(required=True, help_text='网卡信息')    def validate_manufacturer(self, value):        """        自定义字段级别的验证，该方法采用单个参数，即需要验证的字段        value: 前端传过来的 manufacturer        """        try:            logging.info('前端传入的 manufacturer:{}'.format(value))            manufacturers = Manufacturers.objects.get(vendor_name__exact=value)            return manufacturers        except Manufacturers.DoesNotExist:            # 不存在就创建            return self.create_manufacturers(value)    def create_manufacturers(self, vendor_name):        """创建制造商."""        logging.info('创建智商')        return Manufacturers.objects.create(vendor_name=vendor_name)    def validate(self, attrs):        """        执行需要访问多个字段的任何其他验证，请添加一个.validate()方法到Serializer子类中，        采用字段值字典的单个参数        """        logging.info('验证导入的产品型号数据: {}'.format(attrs))  # OrdereDict        manufacturer_obj = attrs['manufacturer']  # <Manufacturers: DELL>        model_name = attrs['model_name']        try:            # 反向查找            attrs['model_name'] = manufacturer_obj.productmodel_set.get(model_name__exact=model_name)        except ProductModel.DoesNotExist:            # 不存在就创建产品型号            attrs['model_name'] = self.create_product_model(manufacturer_obj, model_name)        return attrs    def create_product_model(self, manufacturer_obj, model_name):        """创建产品型号."""        logging.info('创建产品型号(必须是传入实例):{} {}'.format(manufacturer_obj, model_name))        return ProductModel.objects.create(model_name=model_name, vendor=manufacturer_obj)    def create(self, validated_data):        """        validated_data： 验证之后的数据        将数据写入Servers表中        {'ip': '192.168.199.188',         'hostname': 'django-node-1',         'cpu': '8',         'mem': '32',         'disk': '32',         'os': 'Debian9.6',         'manufacturer': <Manufacturers: ali>,         'model_name': <ProductModel: ec2>,         'uuid': '88888888'}         """        logging.info('经过验证之后的数据:{},写到表中'.format(validated_data))        network = validated_data.pop('network')  # 删除 network 字段, 并返回        server_obj = Server.objects.create(**validated_data)  # 创建服务器信息        self.check_network_device(server_obj, network)  # 创建服务器网卡信息        return server_obj    def check_network_device(self, server_obj, network):        """检查服务器有没有指定的网卡信息,并做关联."""        # 所有的网卡信息        network_device_query = server_obj.networkdevice_set.all()        for device in network:            try:                network_device_obj = network_device_query.get(name__exact=device['name'])            except NetworkDevice.DoesNotExist as e:                # 网卡不存在就自动创建                self.check_network_device(server_obj, device)    def create_network_device(self, server_obj, device):        ips = device.pop('ips')        device['host'] = server_obj        return NetworkDevice.objects.create(**device)    def check_ips(self, network_device_obj, ifnets):        ip_query = network_device_obj.ip_set.all()        for ifnet in ifnets:            try:                ip_query.get(ip_addr__exact=ifnet['ip_addr'])            except IP.DoesNotExist as e:                return self.create_ip(network_device_obj, ifnet)    def create_ip(self, network_device_obj, ifnet):        ifnet['device'] = network_device_obj        return IP.objects.create(**ifnet)    def to_representation(self, instance):        ret = {            'hostname': instance.hostname,            'ip': instance.ip        }        return retclass ServerSerializer(serializers.ModelSerializer):    """服务器序列化."""    class Meta:        model = Server        fields = '__all__'class NetworkDeviceSerializer(serializers.ModelSerializer):    """网卡序列化."""    class Meta:        model = NetworkDevice        fields = '__all__'class IPSerializer(serializers.ModelSerializer):    """IP 地址序列化."""    class meta:        model = IP        fiedls = '__all__'